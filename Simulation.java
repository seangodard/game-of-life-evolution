/**
 * Holds the methods used to simulate the genetics algorithm and the rules of Conway's Game of Life
 * @author Sean Godard
 * @references
 *  -http://stackoverflow.com/questions/7206442/printing-all-possible-subsets-of-a-list -> Petar Minchev
 */

import java.awt.Point;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;

public final class Simulation {
	private static Random rand = new Random();

    /**
     * @param cell_start_radius the area that the cells must start within
     * @param sim_lifespan the maximum number of loops to test the fitness within
     * @return the optimal placement of cells within that radius and upper simulation runs bound
     */
	public static CellBoard bruteForceBest(int cell_start_radius, int sim_lifespan) {
		CellBoard best_board = null;
		int best_fitness = 0;
		
		// Create a list of all possible points
		Point tmp_point;
		int num_possible_points = (int) Math.pow(cell_start_radius*2+1, 2);
		Point[] all_points = new Point[num_possible_points];
		int index = 0;
		for (int x = -cell_start_radius; x <= cell_start_radius; x++) {
			for (int y = -cell_start_radius; y<= cell_start_radius;y++) {
				// translate to a point and only draw if its valid
				tmp_point = new Point(x,y);
				all_points[index] = tmp_point;
				index++;
			}
		}
		
		// Trying all possible subsets by pulling points at the indexes determined by Petar Minchev's algorithm
		int num_subsets = (1 << num_possible_points);
		HashSet<Point> next_set = new HashSet<>(); // the next subset of points to try
		CellBoard tmp_board;
		int tmp_fitness;
		for (int i = 1; i < num_subsets; i++){
			// Create the next subset
			for (int j = 0; j < num_possible_points; j++) {
				if ((i & (1 << j)) > 0) { //The j-th element is used
					next_set.add(all_points[j]);
				}
			}
			// Get its fitness
			tmp_board = new CellBoard(next_set, cell_start_radius);
			tmp_fitness = simulatedFitness(tmp_board, sim_lifespan);
			
			// Update the best if its better than the old one
			if (best_board == null || tmp_fitness > best_fitness) {
				best_board = tmp_board;
				best_fitness = tmp_fitness;
			}		
			next_set = new HashSet<>(); // reset for the next cell set
			if (i%1000 == 0) System.out.println(i); // Can delete, just to watch progress
		}
		return best_board; // return the optimal
	}

    /**
     * Update the cell data for the next step in the simulation following the rules:
     *  1. Any live cell with fewer than two live neighbors dies, as if caused by under-population.
     *  2. Any live cell with two or three live neighbors live on to the next generation.
     *  3. Any live cell with more than three live neighbors dies, as if by overcrowding.
     *  4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
     * @param old_board the old board
     * @return a new CellBoard containing the updated cells
     */
	public static UpdatedCellPair updateCells(CellBoard old_board) {
		CellBoard new_board = old_board.copy();
		HashMap<Point, Integer> adj_dead_cells = new HashMap<>();

		Point[] neighboring_points;
		int total_new_cells = 0;

		// Checking rules 1-3 for live cells
		for (Point cell : old_board) {
			neighboring_points = getNeighboringPoints(cell);
			int living_neighbors = 0;

			// getting the number of living cells and tracking nearby dead cells to use later
			for (Point neighbor : neighboring_points) {
				if (old_board.contains(neighbor)) living_neighbors +=1;
				else {
                    if (adj_dead_cells.containsKey(neighbor)) {
                        adj_dead_cells.put(neighbor, adj_dead_cells.get(neighbor) + 1);
                    }
                    else {
                        adj_dead_cells.put(neighbor, 1);
                    }
                }
			}

			// Removes the cell from the next generation if it died by rule 1 or 3
			if (living_neighbors < 2 || living_neighbors > 3) new_board.removeCell(cell);
		}

		// Checking rule 4
		for (Point deadCell : adj_dead_cells.keySet()) {
			// Add the cell as a living cell to the next generation if it follows rule 4
			if (adj_dead_cells.get(deadCell) == 3) {
				new_board.addCell(deadCell);
				total_new_cells++;
			}
		}
		return new UpdatedCellPair(new_board, total_new_cells);
	}

    /**
     * @param initial_board an initial cellBoard to determine the fitness of
     * @param sim_lifespan the maximum number of
     * @return the total number of new cells generated by this initial board within the limit
     */
	public static int simulatedFitness(CellBoard initial_board, int sim_lifespan) {
		int fitness = 0;
		CellBoard old_board = initial_board;
		CellBoard new_board;

		for (int i = 0; i < sim_lifespan; i++) {
			if (old_board.isEmpty()) {
				break;
			}

			UpdatedCellPair tmp = updateCells(old_board);
			new_board = tmp.getBoard();
			fitness += tmp.getNumNewCells();
			old_board = new_board;
		}

		return fitness;
	}

    /**
     * @param cell_point the point of a cell location
     * @return points array of neighboring cell points (later will be judged to be living/dead)
     */
	private static Point[] getNeighboringPoints(Point cell_point) {
		Point neighbor_cells[] = new Point[8];
		int shifts[] = {-1,0,1};
		double adj_x, adj_y;

		int i = 0;
		for (int x : shifts) {
			for(int y : shifts) {
				if (!(x == 0 && y == 0)) {
					adj_x = cell_point.getX()+x;
					adj_y = cell_point.getY()+y;
					Point cell = new Point((int) adj_x,(int) adj_y);
					neighbor_cells[i] = cell;
					i++;
				}
			}
		}
		return neighbor_cells;
	}
}